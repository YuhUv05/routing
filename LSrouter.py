####################################################
# LSrouter.py
# Name: Vu Ba Huy   
# HUID: 23020613
#####################################################

from tkinter import NO
from router import Router


class LSrouter(Router):
    """Link state routing protocol implementation.

        """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        self.G = nx.DiGraph()
        self.G.add_node(str(addr))
        self.forward = {}
        self.linkToPort = {}
        self.portToLink = {}
        self.nodeToLastPacketSeqNum = {}
        self.linkStates = {addr: self.packageLinks()['endpoints']}
        self.seqNumLastSents = -1
        pass
    
    def handlePocket(self, port, packet):
       
        # TODO
        # process incoming packet
        pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceRoute():
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            distanceAddr = packet.distanceAddr
            if(distanceAddr in self.forward):
                portToSend = self.forward[distanceAddr]
                self.send(portToSend, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            packetContent = loads(packet.content)
            seqNum = packetContent["seqNum"]
            endpoints = packetContent["endpoints"]
            nodeItStartedFrom = packet.srcAddr
            
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            if (nodeItStartedFrom not in self.nodeToLastPacketSeqNum or seqNum > self.nodeToLastPacketSeqNum[nodeItStartedFrom]):
                 self.nodeToLastPacketSeqNum[nodeItStartedFrom] = seqNum  # Update this counter 
            # get the old linkState for this node
            if nodeItStartedFrom not in self.linkStates:
                oldLinkStateForThisNode = {}
            else:
                oldLinkStateForThisNode = self.linkStates[nodeItStartedFrom]
            # update the graph for new edges!
            for endPoint, costData in endpoints.items():
                if (endpoint not in oldLinkStateForThisNode):
                    # New edge to add to the graph
                    self.G.add_edge(nodeItStartedFrom, endpoint, cost=costData['costTo'])
                    self.G.add_edge(endpoint, nodeItStartedFrom, cost=costData['costFrom'])
             # update the graph for removed edges
            for endpoint, costData in oldLinkStateForThisNode.items():
                if (endpoint not in endpoints):
                    # this edge has been removed
                    self.G.remove_edge(nodeItStartedFrom, endpoint)
            # update the linkState for this node
            self.linkStates[nodeItStartedFrom] = endpoints;  
            # update forwarding table
            self.updateForwardTable() 
            for portNum, link in self.links.items():
                # get the endpoint of that link
                if(link.e1 == self.addr):
                    target = link.e2
                else:
                    target = link.e1
                if (target.isupper()):
                    self.send(portNum, Packet("ROUTING", nodeItStartedFrom, target, packet.content))
     
    def handle_new_link(self, port, endpoint, cost):
    
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        
        self.updateMyLinkState() 
        # update graph
        strEndPoint = str(endpoint)
        if (not self.G.has_node(strEndpoint)):
            self.G.add_node(strEndPoint)
        self.G.add_edge(self.addr, strEndPoint, cost=cost)
        # update linkToPort
        self.linkToPort[strEndPoint] = port
        self.portToLink[port] = strEndPoint
        self.updateForwardTable()
        # broadcast the new link state of this router to all neighbors
        self.broadcast()
        pass
        
    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        
        self.updateMyLinkState()
        endpoint = self.portToLink[port]
        # updating graph
        self.G.remove_edge(self.addr, endpoint)
        # updating the forwarding table
        self.updateForwardTable()
        # updating linkToPort
        del self.linkToPort[endpoint]
        del self.portToLink[port]
        # broadcast the new link state of this router to all neighbors
        self.broadcast()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            self.broadcast()
            
    def updateForwardTable(self):
        # update the forwarding table
        for target in self.G.nodes():
            if (target.isupper() == False): 
                # Compute new shortest path
                if (nx.has_path(self.G, self.addr, target)):
                    # see if there is path
                    # print (" Is there edge between G and E: " + str(self.G.has_edge("G", "E")))
                    path = nx.shortest_path(self.G, source=self.addr, target=target, weight="cost")
                    if (path[1] in self.linkToPort):
                        portToSend = self.linkToPort[path[1]]
                        self.forward[target] = portToSend
                else:
                    # there is no path
                    if(target in self.forward):
                        #if we had a path before
                        # remove that path and carry on to the next node
                        del self.forward[target]
                        
    def broadcast(self):
        self.seqNumLastSent = self.seqNumLastSent + 1
        # for each of my links
        packetContent = self.packageLinks()
        packetContent['seqNum'] = self.seqNumLastSents
        for portNum, link in self.links.items():
            # get the endpoint of that link
            if (link.e1 == self.addr):
                target = link.e2
            else:
                target = link.e1
            if (target.isupper()):
                self.send(portNum, Packet("ROUTING", self.addr, target, dumps(packetContent)))
                
    def updateMyLinkState(self):
        self.linkStates[self.addr] = self.packageLinks()['endpoints']
        
    def packageLinks(self):
        result = {}
        result['src'] = self.addr
        result['endpoints'] = self.getNeighbors()
        return result
    
    def getNeighbors(self):
        neighbor = {}
        for link in self.links.values():
            if (link.e1 == self.addr):
                target = str(link.e2)
                costTo = link.l12/link.latencyMultiplayer
                costFrom = link.l21/link.latencyMultiplayer
            else:
                target = str(link.e1)
                costTo = link.l21/link.latencyMultiplayer
                costFrom = link.l12/link.latencyMultiplayer
            neighbors[target] = {'costTo':costTo, 'costFrom':costFrom}
        return neighbors
                
    def debugString(self):
        res=""
        # res = str(self.links) + "\n"
        for line in nx.generate_edgelist(self.G, data=true):
            res = res + line + "\n"
        res = res + "seqNumLastSeenByNodes:" + str(self.nodeToLastPacketSeqNum) + "\n"
        res = res + "linkStates" + str(self.linkStates)
        res = res + "forward table:" + str(self.forward) + "\n"
        
        return res
